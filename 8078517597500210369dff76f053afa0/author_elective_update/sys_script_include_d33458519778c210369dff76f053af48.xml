<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="DELETE">
        <access>package_private</access>
        <active>true</active>
        <api_name>global.MagdaNestedLevelSync</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>MagdaNestedLevelSync</name>
        <script><![CDATA[var MagdaNestedLevelSync = Class.create();
MagdaNestedLevelSync.TABLE = 'u_data_driven_definition';
MagdaNestedLevelSync.PROPERTIES = {
    LOGGING: 'enable.logging',
    BATCHSIZE: 'batchsize.data.driven',
    ENABLE_PUSHING: 'enable.pushing',
    TARGET_INSTANCE: 'target.instance',
    PUSHING_CREDENTIAL_ID: 'pushing.credential.id'
};
MagdaNestedLevelSync.prototype = {
        initialize: function() {
            this.payload = {};
            this.refPayload;
            this.targetID = "";
            this.nestedLevel;
        },
        /**
         * Process and push data from the source instance to the target instance based on data driven definition table
         *@returns {void}   
         */
        pushData: function() {
            if (this.canPush()) {
                var batchSize = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.BATCHSIZE);
                var batch = [];
                var tableGR = new GlideRecord(MagdaNestedLevelSync.TABLE);
                tableGR.addQuery('u_active', true);
                tableGR.orderByDesc('u_order');
                tableGR.query();

                while (tableGR.next()) {
                    try {
                        var cmdbTable = JSON.parse(tableGR.getValue('u_configuration'));
                        this.nestedLevel = JSON.parse(tableGR.getValue('u_nested_level'));
                        for (obj in cmdbTable) {
                            var sourTable = cmdbTable[obj]['sourceTable'];
                            var refTables = [];
                            for (var keys in cmdbTable[obj]) {
                                if (keys.startsWith('refTable')) {
                                    refTables.push(cmdbTable[obj][keys]);
                                }

                            }
                            var searchGR = new GlideRecord(sourTable);
                            searchGR.query();
                            while (searchGR.next()) {
                                this.syncData(searchGR, sourTable, refTables);
                            }
                        }
                    } catch (e) {
                        gs.error(e);
                    }
                }
            }
        },
        /**
         * Verify if data pushing is enabled
         * 
         * @returns {boolean} true if pushing is enables otherwise false
         * 
         */
        canPush: function() {
            return gs.getProperty(MagdaNestedLevelSync.PROPERTIES.ENABLE_PUSHING) == 'true';
        },
        /**
         * Create the cmdbPayload for the cmdb records to be pushed to the target instance
         * 
         * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
         * @cmdbClass {String} The name of the CMDB class.
         * @returns {Object} The payload object with corresponding field values.
         * 
         */
        // createcmdbPayload: function(cmdbGR, cmdbClass) {
        //     var cmdbPayload = {};
        //     var dictionaryGR = new GlideRecord('sys_dictionary');
        //     dictionaryGR.addQuery('name', cmdbClass);
        //     dictionaryGR.query();
        //     while (dictionaryGR.next()) {
        //         var fieldName = dictionaryGR.getValue('element');
        //         if (cmdbGR.isValidField(fieldName)) {
        //             var fieldValue = cmdbGR.getValue(fieldName);
        //             cmdbPayload[fieldName] = fieldValue;
        //         }
        //     }
        //     cmdbPayload['correlation_id'] = cmdbGR.getUniqueValue();
        //     return cmdbPayload;
        // },
        /**
         * Creates an object representation of all reference fields for a given CMDB class and its records.
         * 
         * @refTables {Array} The array of reference tables' names.
         * @currentGR {GlideRecord} The current GlideRecord being processed.
         * @currentNestedLevel {Number} The current level of nesting in the data structure.
         * @returns {Object} An object representing the nested references.
         * 
         */
        createReferenceObject: function(refTables, currentGR, currentNestedLevel) {
            this.setlogging('info', "Starting createReferenceObject with nested level: " + currentNestedLevel);

            var referenceObject = {};
            if (currentNestedLevel > this.nestedLevel) {
                return;
            }
            var fieldList = new GlideRecordUtil().getFields(currentGR);

            for (var i = 0; i < fieldList.length; i++) {
                var fieldName = fieldList[i];
                var fieldValue = currentGR[fieldName];

                if (currentNestedLevel == 0) {
                    this.payload[fieldName] = fieldValue.getDisplayValue() !== '' ? fieldValue.getDisplayValue() : null;

                    if (fieldValue.getED().getInternalType() == 'reference' && refTables.includes(fieldValue.getReferenceTable())) {
                        var refRecord = currentGR[fieldName].getRefRecord();
                        if (refRecord.isValidRecord()) {
                            var dataObject = this.createReferenceObject(refTables, refRecord, currentNestedLevel + 1);
                            if (currentNestedLevel < this.nestedLevel) {
                                var metaObject = {
                                    sys_class_name: refRecord.getTableName(),
                                    nestedLevel: currentNestedLevel + 1,
                                    sourceInstanceSysID: refRecord.getUniqueValue(),
                                    targetInstanceSysID: ""
                                };
                                this.setlogging('info', "Meta Object is " + JSON.stringify(metaObject, "", 2));
                                this.setlogging('info', "Data Object is " + JSON.stringify(dataObject, "", 2));
                                referenceObject[fieldName] = {
                                    meta: metaObject,
                                    data: dataObject
                                };
                            }
                        }
                    } else {
                        referenceObject[fieldName] = currentGR[fieldName].getDisplayValue() != '' ? currentGR[fieldName].getDisplayValue() : null;
                    }
                    if (currentNestedLevel == 0) {
                        this.payload['correlation_id'] = currentGR.getUniqueValue();
                    }
                }
			}
                return referenceObject;
            },

            /**
             * Synchronizes data from CMDB CI and reference records between instances.
             * 
             * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
             * @cmdbClass {String} The name of the CMDB class.
             * @refTables {Array} The array of reference tables' names.
             * @returns {void}
             * 
             */
            syncData: function(cmdbGR, cmdbClass, refTables) {
                    try {
                        var masterData = this.createReferenceObject(refTables, cmdbGR, 0);
                        this.setlogging('info', "MasterData: " + JSON.stringify(masterData, null, 2));
                        this.processData(masterData, "");
                        var url;
                        var method = 'POST';
                        var correlationId = this.payload['correlation_id'];
                        if (correlationId) {
                            url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=correlation_id=' + correlationId;
                            var returnObj = this.executeRESTCall(url, 'GET', null, cmdbClass);
                            if (returnObj && returnObj.responseBody && returnObj.responseBody.result && returnObj.responseBody.result.length > 0) {
                                url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '/' + returnObj.responseBody.result[0].sys_id;
                                method = 'PUT';
                            }
                        } else {
                            url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass;
                        }
                        // Execute POST or PUT
                        this.executeRESTCall(url, method, this.payload, cmdbClass);

                    } catch (e) {
                        this.setlogging(e);
                    }
                },
                /**
                 * Processes nested data for synchronization.
                 * 
                 * @masterData {Object} The master data object to process.
                 * @path {String} The current path within the nested data structure.
                 * 
                 */
                processData: function(masterData, path) {
                    for (var key in masterData) {
                        var item = masterData[key];
                        if (typeof item == 'object' && item !== null && item.meta && item.data) {
                            this.setlogging('info', "Processing nested reference for: " + key);
                            this.processData(item.masterData, path + key + ".");
                            this.syncReferenceData(item, item.meta.sys_class_name, path + key);
                        }
                    }
                },
                /**
                 * Synchronizes reference data for a specific table and path.
                 * 
                 * @item {Object} The item to synchronize.
                 * @refTable {String} The reference table name.
                 * @path {String} The path within the nested data structure.
                 * 
                 */
                syncReferenceData: function(item, refTable, path) {
                    var payload = item.data;
                    for (var key in payload) {
                        if (typeof payload[key] == 'object' && payload[key] !== null) {
                            payload[key] = item.data[key].meta.sourceInstanceSysID;
                        }
                    }
                    this.setlogging('info', "Sync data for table: " + refTable + " at path: " + path + " with payload: " + JSON.stringify(payload, "", 2));
                    var name = encodeURIComponent(payload['name']);
                    var url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + refTable + '?sysparm_query=name%3D' + name;
                    var returnObj = this.executeRESTCall(url, 'GET', payload, refTable);
                    this.setlogging('info', "Return obj for reference record" + JSON.stringify(returnObj));
                    this.setlogging('info', "URL for get:" + url);
                    if (returnObj == null) {
                        var postUrl = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + refTable;
                        this.setlogging('info', "URL for POST:" + postUrl);
                        var postResponse = this.executeRESTCall(postUrl, 'POST', payload, refTable);
                        this.setlogging('info', "Post response for reference table" + JSON.stringify(postResponse) + ",table:" + refTable);
                        this.setlogging('info', "New POST sys_id is: " + postResponse.responseBody.result.sys_id);
                        item.meta.targetInstanceSysID = postResponse.responseBody.result.sys_id;
                    }
                    if (returnObj) {
                        this.setlogging("info", "returnObj.responseBody.result[0].sys_id " + returnObj.responseBody.result[0].sys_id);
                        var putUrl = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + refTable + '/' + returnObj.responseBody.result[0].sys_id;
                        this.setlogging('info', "URL for PUT:" + putUrl);
                        var putResponse = this.executeRESTCall(putUrl, 'PUT', payload, refTable);
                    }
                },

                /** 
                 * Create cmdb_ci record in the target instance
                 * 
                 * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
                 * @cmdbClass {String} The name of the CMDB class.
                 * @refTables {Array} The array of reference tables' names.
                 * @returns {void}
                 * 
                 */
                // postData: function(cmdbGR, cmdbClass, refTables) {
                //     try {
                //         gs.log("this.payload: " + JSON.stringify(this.payload, "", 2));
                //         var url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass;
                //         this.syncData(cmdbGR, cmdbClass, refTables);
                //         this.executeRESTCall(url, 'POST', this.payload, cmdbClass);
                //     } catch (e) {
                //         gs.error(e);
                //     }
                // },
                /** 
                 * Create the payload for cmdb_ci table, verify which REST API Method need to be used for syncronization and execute cmdb definition
                 * 
                 * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
                 * @cmdbClass {String} The name of the CMDB class.
                 * @refTables {Array} The array of reference tables' names.
                 * @returns {void}
                 * 
                 */
                // executeCMDBDefinition: function(cmdbGR, cmdbClass, refTables) {
                //     try {
                //     //     var url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=correlation_id%' + cmdbGR.getUniqueValue();
                //     //    // this.payload = this.createcmdbPayload(cmdbGR, cmdbClass);
                //     //     var returnObj = this.executeRESTCall(url, 'GET', cmdbGR, cmdbClass);
                //         // if (returnObj == null) {
                //         //     this.postData(cmdbGR, cmdbClass, refTables);
                //         // } else {
                //             this.syncData(cmdbGR, cmdbClass, refTables);
                //         // }
                //     } catch (e) {
                //         gs.error(e);
                //     }
                // },
                /** 
                 * Construct and execute REST API Call that needs to be used for syncronization
                 * 
                 * @url {String} The URL for the REST call.
                 * @method {String} The HTTP method (e.g., GET, POST).
                 * @payload {Object} The payload for the REST call.
                 * @cmdbClass {String} The name of the CMDB class.
                 * @returns {Object} The response from the REST call.
                 * 
                 */
                executeRESTCall: function(url, method, payload, cmdbClass) {
                    var provider = new sn_cc.StandardCredentialsProvider();
                    var credentials = provider.getCredentialByID(gs.getProperty(MagdaNestedLevelSync.PROPERTIES.PUSHING_CREDENTIAL_ID));
                    var user = credentials.getAttribute("user_name");
                    var pass = credentials.getAttribute("password");
                    var request = new sn_ws.RESTMessageV2();
                    request.setBasicAuth(user, pass);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader('Content-Type', 'application/json');
                    request.setHttpMethod(method);
                    if ((method == 'PUT' && cmdbClass.includes('cmdb_ci')) || (method == 'POST' && cmdbClass.includes('cmdb_ci'))) {
                        request.setRequestBody(JSON.stringify(payload));
                    } else if (method == 'PUT' || method == 'POST') {
                        request.setRequestBody(JSON.stringify(payload));
                    }
                    if (method == 'GET' && cmdbClass.includes('cmdb_ci')) {
                        url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=correlation_id%3D' + payload['sys_id'];
                        this.setlogging('info', "URL FOR GET cmdb_ci RECORD IS" + url);
                    } else if (method == 'GET') {
                        var name = encodeURIComponent(payload['name']);
                        url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=name%3D' + name;
                        this.setlogging('info', "URL FOR GET REFERENCE RECORD IS" + url);
                    }

                    request.setEndpoint(url);
                    var response = request.execute();
                    var responseBody = JSON.parse(response.getBody());
                    var httpsStatus = response.getStatusCode();
                    this.setlogging('info', 'Response body for' + method + ' is' + JSON.stringify(responseBody, "", 2));
                    if (method == 'GET' && responseBody.result.length == 0) {
                        return null;
                    }
                    return {
                        'responseBody': responseBody,
                        'httpsStatus': httpsStatus
                    };
                },
                /**
                 * Set logging for other functions in the Script Include
                 * 
                 * @method setlogging
                 * @verbosity {String} String value for the verbosity of the logs
                 * @message {String} Message that is logged
                 * @returns
                 *
                 */
                setlogging: function(verbosity, message) {
                    if (gs.getProperty(MagdaNestedLevelSync.PROPERTIES.LOGGING === "true")) return;
                    switch (verbosity) {
                        case "error":
                            gs.error(message);
                            break;
                        case "warn":
                            gs.warn(message);
                            break;
                        case "info":
                            gs.info(message);
                            break;
                        case "debug":
                            gs.debug(message);
                            break;
                        default:
                            break;
                    }
                },
                type: 'MagdaNestedLevelSync'
        };]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>magda.gursca</sys_created_by>
        <sys_created_on>2024-03-06 09:57:08</sys_created_on>
        <sys_id>d33458519778c210369dff76f053af48</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>MagdaNestedLevelSync</sys_name>
        <sys_package display_value="Data Driven Definition" source="8078517597500210369dff76f053afa0">8078517597500210369dff76f053afa0</sys_package>
        <sys_policy/>
        <sys_scope display_value="Data Driven Definition">8078517597500210369dff76f053afa0</sys_scope>
        <sys_update_name>sys_script_include_d33458519778c210369dff76f053af48</sys_update_name>
        <sys_updated_by>magda.gursca</sys_updated_by>
        <sys_updated_on>2024-03-06 09:57:08</sys_updated_on>
    </sys_script_include>
    <sys_update_version action="INSERT_OR_UPDATE">
        <action>DELETE</action>
        <application display_value="Synchronize CMDB Data Between Instances">8078517597500210369dff76f053afa0</application>
        <file_path/>
        <instance_id>064ad2f9db47a410ad8dd7c8f49619ce</instance_id>
        <instance_name>dev107996</instance_name>
        <name>sys_script_include_d33458519778c210369dff76f053af48</name>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;&lt;sys_script_include action="INSERT_OR_UPDATE"&gt;&lt;access&gt;package_private&lt;/access&gt;&lt;active&gt;true&lt;/active&gt;&lt;api_name&gt;global.MagdaNestedLevelSync&lt;/api_name&gt;&lt;caller_access/&gt;&lt;client_callable&gt;false&lt;/client_callable&gt;&lt;description/&gt;&lt;name&gt;MagdaNestedLevelSync&lt;/name&gt;&lt;script&gt;&lt;![CDATA[var MagdaNestedLevelSync = Class.create();
MagdaNestedLevelSync.TABLE = 'u_data_driven_definition';
MagdaNestedLevelSync.PROPERTIES = {
    LOGGING: 'enable.logging',
    BATCHSIZE: 'batchsize.data.driven',
    ENABLE_PUSHING: 'enable.pushing',
    TARGET_INSTANCE: 'target.instance',
    PUSHING_CREDENTIAL_ID: 'pushing.credential.id'
};
MagdaNestedLevelSync.prototype = {
        initialize: function() {
            this.payload = {};
            this.refPayload;
            this.targetID = "";
            this.nestedLevel;
        },
        /**
         * Process and push data from the source instance to the target instance based on data driven definition table
         *@returns {void}   
         */
        pushData: function() {
            if (this.canPush()) {
                var batchSize = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.BATCHSIZE);
                var batch = [];
                var tableGR = new GlideRecord(MagdaNestedLevelSync.TABLE);
                tableGR.addQuery('u_active', true);
                tableGR.orderByDesc('u_order');
                tableGR.query();

                while (tableGR.next()) {
                    try {
                        var cmdbTable = JSON.parse(tableGR.getValue('u_configuration'));
                        this.nestedLevel = JSON.parse(tableGR.getValue('u_nested_level'));
                        for (obj in cmdbTable) {
                            var sourTable = cmdbTable[obj]['sourceTable'];
                            var refTables = [];
                            for (var keys in cmdbTable[obj]) {
                                if (keys.startsWith('refTable')) {
                                    refTables.push(cmdbTable[obj][keys]);
                                }

                            }
                            var searchGR = new GlideRecord(sourTable);
                            searchGR.query();
                            while (searchGR.next()) {
                                this.syncData(searchGR, sourTable, refTables);
                            }
                        }
                    } catch (e) {
                        gs.error(e);
                    }
                }
            }
        },
        /**
         * Verify if data pushing is enabled
         * 
         * @returns {boolean} true if pushing is enables otherwise false
         * 
         */
        canPush: function() {
            return gs.getProperty(MagdaNestedLevelSync.PROPERTIES.ENABLE_PUSHING) == 'true';
        },
        /**
         * Create the cmdbPayload for the cmdb records to be pushed to the target instance
         * 
         * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
         * @cmdbClass {String} The name of the CMDB class.
         * @returns {Object} The payload object with corresponding field values.
         * 
         */
        // createcmdbPayload: function(cmdbGR, cmdbClass) {
        //     var cmdbPayload = {};
        //     var dictionaryGR = new GlideRecord('sys_dictionary');
        //     dictionaryGR.addQuery('name', cmdbClass);
        //     dictionaryGR.query();
        //     while (dictionaryGR.next()) {
        //         var fieldName = dictionaryGR.getValue('element');
        //         if (cmdbGR.isValidField(fieldName)) {
        //             var fieldValue = cmdbGR.getValue(fieldName);
        //             cmdbPayload[fieldName] = fieldValue;
        //         }
        //     }
        //     cmdbPayload['correlation_id'] = cmdbGR.getUniqueValue();
        //     return cmdbPayload;
        // },
        /**
         * Creates an object representation of all reference fields for a given CMDB class and its records.
         * 
         * @refTables {Array} The array of reference tables' names.
         * @currentGR {GlideRecord} The current GlideRecord being processed.
         * @currentNestedLevel {Number} The current level of nesting in the data structure.
         * @returns {Object} An object representing the nested references.
         * 
         */
        createReferenceObject: function(refTables, currentGR, currentNestedLevel) {
            this.setlogging('info', "Starting createReferenceObject with nested level: " + currentNestedLevel);

            var referenceObject = {};
            if (currentNestedLevel &gt; this.nestedLevel) {
                return;
            }
            var fieldList = new GlideRecordUtil().getFields(currentGR);

            for (var i = 0; i &lt; fieldList.length; i++) {
                var fieldName = fieldList[i];
                var fieldValue = currentGR[fieldName];

                if (currentNestedLevel == 0) {
                    this.payload[fieldName] = fieldValue.getDisplayValue() !== '' ? fieldValue.getDisplayValue() : null;

                    if (fieldValue.getED().getInternalType() == 'reference' &amp;&amp; refTables.includes(fieldValue.getReferenceTable())) {
                        var refRecord = currentGR[fieldName].getRefRecord();
                        if (refRecord.isValidRecord()) {
                            var dataObject = this.createReferenceObject(refTables, refRecord, currentNestedLevel + 1);
                            if (currentNestedLevel &lt; this.nestedLevel) {
                                var metaObject = {
                                    sys_class_name: refRecord.getTableName(),
                                    nestedLevel: currentNestedLevel + 1,
                                    sourceInstanceSysID: refRecord.getUniqueValue(),
                                    targetInstanceSysID: ""
                                };
                                this.setlogging('info', "Meta Object is " + JSON.stringify(metaObject, "", 2));
                                this.setlogging('info', "Data Object is " + JSON.stringify(dataObject, "", 2));
                                referenceObject[fieldName] = {
                                    meta: metaObject,
                                    data: dataObject
                                };
                            }
                        }
                    } else {
                        referenceObject[fieldName] = currentGR[fieldName].getDisplayValue() != '' ? currentGR[fieldName].getDisplayValue() : null;
                    }
                    if (currentNestedLevel == 0) {
                        this.payload['correlation_id'] = currentGR.getUniqueValue();
                    }
                }
			}
                return referenceObject;
            },

            /**
             * Synchronizes data from CMDB CI and reference records between instances.
             * 
             * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
             * @cmdbClass {String} The name of the CMDB class.
             * @refTables {Array} The array of reference tables' names.
             * @returns {void}
             * 
             */
            syncData: function(cmdbGR, cmdbClass, refTables) {
                    try {
                        var masterData = this.createReferenceObject(refTables, cmdbGR, 0);
                        this.setlogging('info', "MasterData: " + JSON.stringify(masterData, null, 2));
                        this.processData(masterData, "");
                        var url;
                        var method = 'POST';
                        var correlationId = this.payload['correlation_id'];
                        if (correlationId) {
                            url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=correlation_id=' + correlationId;
                            var returnObj = this.executeRESTCall(url, 'GET', null, cmdbClass);
                            if (returnObj &amp;&amp; returnObj.responseBody &amp;&amp; returnObj.responseBody.result &amp;&amp; returnObj.responseBody.result.length &gt; 0) {
                                url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '/' + returnObj.responseBody.result[0].sys_id;
                                method = 'PUT';
                            }
                        } else {
                            url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass;
                        }
                        // Execute POST or PUT
                        this.executeRESTCall(url, method, this.payload, cmdbClass);

                    } catch (e) {
                        this.setlogging(e);
                    }
                },
                /**
                 * Processes nested data for synchronization.
                 * 
                 * @masterData {Object} The master data object to process.
                 * @path {String} The current path within the nested data structure.
                 * 
                 */
                processData: function(masterData, path) {
                    for (var key in masterData) {
                        var item = masterData[key];
                        if (typeof item == 'object' &amp;&amp; item !== null &amp;&amp; item.meta &amp;&amp; item.data) {
                            this.setlogging('info', "Processing nested reference for: " + key);
                            this.processData(item.masterData, path + key + ".");
                            this.syncReferenceData(item, item.meta.sys_class_name, path + key);
                        }
                    }
                },
                /**
                 * Synchronizes reference data for a specific table and path.
                 * 
                 * @item {Object} The item to synchronize.
                 * @refTable {String} The reference table name.
                 * @path {String} The path within the nested data structure.
                 * 
                 */
                syncReferenceData: function(item, refTable, path) {
                    var payload = item.data;
                    for (var key in payload) {
                        if (typeof payload[key] == 'object' &amp;&amp; payload[key] !== null) {
                            payload[key] = item.data[key].meta.sourceInstanceSysID;
                        }
                    }
                    this.setlogging('info', "Sync data for table: " + refTable + " at path: " + path + " with payload: " + JSON.stringify(payload, "", 2));
                    var name = encodeURIComponent(payload['name']);
                    var url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + refTable + '?sysparm_query=name%3D' + name;
                    var returnObj = this.executeRESTCall(url, 'GET', payload, refTable);
                    this.setlogging('info', "Return obj for reference record" + JSON.stringify(returnObj));
                    this.setlogging('info', "URL for get:" + url);
                    if (returnObj == null) {
                        var postUrl = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + refTable;
                        this.setlogging('info', "URL for POST:" + postUrl);
                        var postResponse = this.executeRESTCall(postUrl, 'POST', payload, refTable);
                        this.setlogging('info', "Post response for reference table" + JSON.stringify(postResponse) + ",table:" + refTable);
                        this.setlogging('info', "New POST sys_id is: " + postResponse.responseBody.result.sys_id);
                        item.meta.targetInstanceSysID = postResponse.responseBody.result.sys_id;
                    }
                    if (returnObj) {
                        this.setlogging("info", "returnObj.responseBody.result[0].sys_id " + returnObj.responseBody.result[0].sys_id);
                        var putUrl = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + refTable + '/' + returnObj.responseBody.result[0].sys_id;
                        this.setlogging('info', "URL for PUT:" + putUrl);
                        var putResponse = this.executeRESTCall(putUrl, 'PUT', payload, refTable);
                    }
                },

                /** 
                 * Create cmdb_ci record in the target instance
                 * 
                 * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
                 * @cmdbClass {String} The name of the CMDB class.
                 * @refTables {Array} The array of reference tables' names.
                 * @returns {void}
                 * 
                 */
                // postData: function(cmdbGR, cmdbClass, refTables) {
                //     try {
                //         gs.log("this.payload: " + JSON.stringify(this.payload, "", 2));
                //         var url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass;
                //         this.syncData(cmdbGR, cmdbClass, refTables);
                //         this.executeRESTCall(url, 'POST', this.payload, cmdbClass);
                //     } catch (e) {
                //         gs.error(e);
                //     }
                // },
                /** 
                 * Create the payload for cmdb_ci table, verify which REST API Method need to be used for syncronization and execute cmdb definition
                 * 
                 * @cmdbGR {GlideRecord} The GlideRecord of the CMDB record.
                 * @cmdbClass {String} The name of the CMDB class.
                 * @refTables {Array} The array of reference tables' names.
                 * @returns {void}
                 * 
                 */
                // executeCMDBDefinition: function(cmdbGR, cmdbClass, refTables) {
                //     try {
                //     //     var url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=correlation_id%' + cmdbGR.getUniqueValue();
                //     //    // this.payload = this.createcmdbPayload(cmdbGR, cmdbClass);
                //     //     var returnObj = this.executeRESTCall(url, 'GET', cmdbGR, cmdbClass);
                //         // if (returnObj == null) {
                //         //     this.postData(cmdbGR, cmdbClass, refTables);
                //         // } else {
                //             this.syncData(cmdbGR, cmdbClass, refTables);
                //         // }
                //     } catch (e) {
                //         gs.error(e);
                //     }
                // },
                /** 
                 * Construct and execute REST API Call that needs to be used for syncronization
                 * 
                 * @url {String} The URL for the REST call.
                 * @method {String} The HTTP method (e.g., GET, POST).
                 * @payload {Object} The payload for the REST call.
                 * @cmdbClass {String} The name of the CMDB class.
                 * @returns {Object} The response from the REST call.
                 * 
                 */
                executeRESTCall: function(url, method, payload, cmdbClass) {
                    var provider = new sn_cc.StandardCredentialsProvider();
                    var credentials = provider.getCredentialByID(gs.getProperty(MagdaNestedLevelSync.PROPERTIES.PUSHING_CREDENTIAL_ID));
                    var user = credentials.getAttribute("user_name");
                    var pass = credentials.getAttribute("password");
                    var request = new sn_ws.RESTMessageV2();
                    request.setBasicAuth(user, pass);
                    request.setRequestHeader("Accept", "application/json");
                    request.setRequestHeader('Content-Type', 'application/json');
                    request.setHttpMethod(method);
                    if ((method == 'PUT' &amp;&amp; cmdbClass.includes('cmdb_ci')) || (method == 'POST' &amp;&amp; cmdbClass.includes('cmdb_ci'))) {
                        request.setRequestBody(JSON.stringify(payload));
                    } else if (method == 'PUT' || method == 'POST') {
                        request.setRequestBody(JSON.stringify(payload));
                    }
                    if (method == 'GET' &amp;&amp; cmdbClass.includes('cmdb_ci')) {
                        url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=correlation_id%3D' + payload['sys_id'];
                        this.setlogging('info', "URL FOR GET cmdb_ci RECORD IS" + url);
                    } else if (method == 'GET') {
                        var name = encodeURIComponent(payload['name']);
                        url = gs.getProperty(MagdaNestedLevelSync.PROPERTIES.TARGET_INSTANCE) + '/api/now/table/' + cmdbClass + '?sysparm_query=name%3D' + name;
                        this.setlogging('info', "URL FOR GET REFERENCE RECORD IS" + url);
                    }

                    request.setEndpoint(url);
                    var response = request.execute();
                    var responseBody = JSON.parse(response.getBody());
                    var httpsStatus = response.getStatusCode();
                    this.setlogging('info', 'Response body for' + method + ' is' + JSON.stringify(responseBody, "", 2));
                    if (method == 'GET' &amp;&amp; responseBody.result.length == 0) {
                        return null;
                    }
                    return {
                        'responseBody': responseBody,
                        'httpsStatus': httpsStatus
                    };
                },
                /**
                 * Set logging for other functions in the Script Include
                 * 
                 * @method setlogging
                 * @verbosity {String} String value for the verbosity of the logs
                 * @message {String} Message that is logged
                 * @returns
                 *
                 */
                setlogging: function(verbosity, message) {
                    if (gs.getProperty(MagdaNestedLevelSync.PROPERTIES.LOGGING === "true")) return;
                    switch (verbosity) {
                        case "error":
                            gs.error(message);
                            break;
                        case "warn":
                            gs.warn(message);
                            break;
                        case "info":
                            gs.info(message);
                            break;
                        case "debug":
                            gs.debug(message);
                            break;
                        default:
                            break;
                    }
                },
                type: 'MagdaNestedLevelSync'
        };]]&gt;&lt;/script&gt;&lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;&lt;sys_created_by&gt;magda.gursca&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2024-03-06 09:57:08&lt;/sys_created_on&gt;&lt;sys_id&gt;d33458519778c210369dff76f053af48&lt;/sys_id&gt;&lt;sys_mod_count&gt;0&lt;/sys_mod_count&gt;&lt;sys_name&gt;MagdaNestedLevelSync&lt;/sys_name&gt;&lt;sys_package display_value="Data Driven Definition" source="8078517597500210369dff76f053afa0"&gt;8078517597500210369dff76f053afa0&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_scope display_value="Data Driven Definition"&gt;8078517597500210369dff76f053afa0&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_script_include_d33458519778c210369dff76f053af48&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;magda.gursca&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2024-03-06 09:57:08&lt;/sys_updated_on&gt;&lt;/sys_script_include&gt;&lt;/record_update&gt;</payload>
        <payload_hash>-402718461</payload_hash>
        <record_name>MagdaNestedLevelSync</record_name>
        <reverted_from/>
        <source>932a9df597500210369dff76f053afd9</source>
        <source_table>sys_update_set</source_table>
        <state>previous</state>
        <sys_created_by>magda.gursca</sys_created_by>
        <sys_created_on>2024-03-06 09:57:08</sys_created_on>
        <sys_id>2194945d9738c210369dff76f053af39</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_recorded_at>18e133203100000001</sys_recorded_at>
        <sys_updated_by>magda.gursca</sys_updated_by>
        <sys_updated_on>2024-03-06 09:57:08</sys_updated_on>
        <type>Script Include</type>
        <update_guid>2594945d4a38c210b8cf359d475e2e38</update_guid>
        <update_guid_history>2594945d4a38c210b8cf359d475e2e38:-402718461</update_guid_history>
    </sys_update_version>
    <sys_metadata_delete action="INSERT_OR_UPDATE">
        <sys_audit_delete/>
        <sys_class_name>sys_metadata_delete</sys_class_name>
        <sys_created_by>magda.gursca</sys_created_by>
        <sys_created_on>2024-03-06 10:02:27</sys_created_on>
        <sys_db_object display_value="" name="sys_script_include">sys_script_include</sys_db_object>
        <sys_id>1d0024100d4a4ec7847a617f46d6cc51</sys_id>
        <sys_metadata>d33458519778c210369dff76f053af48</sys_metadata>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>MagdaNestedLevelSync</sys_name>
        <sys_package display_value="Synchronize CMDB Data Between Instances" source="8078517597500210369dff76f053afa0">8078517597500210369dff76f053afa0</sys_package>
        <sys_parent/>
        <sys_policy/>
        <sys_scope display_value="Synchronize CMDB Data Between Instances">8078517597500210369dff76f053afa0</sys_scope>
        <sys_scope_delete display_value="">137cff71858e4bf182a22564b6dec841</sys_scope_delete>
        <sys_update_name>sys_script_include_d33458519778c210369dff76f053af48</sys_update_name>
        <sys_update_version display_value="sys_script_include_d33458519778c210369dff76f053af48">2194945d9738c210369dff76f053af39</sys_update_version>
        <sys_updated_by>magda.gursca</sys_updated_by>
        <sys_updated_on>2024-03-06 10:02:27</sys_updated_on>
    </sys_metadata_delete>
</record_update>
